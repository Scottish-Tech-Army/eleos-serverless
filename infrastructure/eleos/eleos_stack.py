from aws_cdk import (
    Duration,
    RemovalPolicy,
    Stack,
    aws_ecs as ecs, 
    aws_ecs_patterns as ecs_patterns, 
    aws_ec2 as ec2,
    aws_rds as rds,
    aws_efs as efs,
    aws_iam as iam,
    aws_lambda as lambda_,
    aws_apigateway as apigateway,
    aws_s3 as s3,
    aws_lambda_event_sources as event_sources,
    CfnOutput
)
from constructs import Construct

class EleosStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, odoo_version: str, environ: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)
    
        ## Nat Instance
        # Create a new NAT instance
        nat_gateway_provider = ec2.NatProvider.instance(
            instance_type=ec2.InstanceType('t3.nano')
            )

        # VPC
        vpc = ec2.Vpc(self, "Vpc", 
            max_azs=2,   # default is all AZs in region = 3
            nat_gateways=1, # default is one in each zone. Cheaper for us to create a NAT instance?
            nat_gateway_provider=nat_gateway_provider
            )

        # ecs cluster for odoo container
        cluster = ecs.Cluster(self, "Cluster", vpc=vpc)
        
        '''
        # Parameter group for database cluster
        parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", 
                "default.aurora-postgresql13",   # was default.aurora-postgresql10
                )

        # Aurora serverless postgresql db
        dbcluster = rds.ServerlessCluster(self, "postgres",
            engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
            #parameter_group=parameter_group, 
            vpc=vpc, 
            default_database_name="postgres", # VERY IMPORTANT!!! NEEDS TO BE "postgres" !!!
            credentials=rds.Credentials.from_generated_secret("odoo"), # generate secret password for user 'odoo'
            scaling=rds.ServerlessScalingOptions(
                auto_pause=Duration.minutes(20),  # default is to pause after 5 minutes of idle time
                min_capacity=rds.AuroraCapacityUnit.ACU_2,  # default is 2 Aurora capacity units (ACUs)
                max_capacity=rds.AuroraCapacityUnit.ACU_4),
            removal_policy=RemovalPolicy.DESTROY      # dev
            )
        '''

        ## RDS DATABASE - mysql
        ## https://aws.amazon.com/rds/instance-types/
        ## https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_rds/DatabaseInstance.html
        
        data_base = rds.DatabaseInstance(self, "postgres",
            vpc=vpc,
            engine=rds.DatabaseInstanceEngine.POSTGRES,
            instance_type=ec2.InstanceType('t4g.micro'), #https://aws.amazon.com/rds/mysql/pricing/?pg=pr&loc=2
            allocated_storage=5,
            max_allocated_storage=20, #GiB
            database_name="postgres",
            credentials=rds.Credentials.from_generated_secret("odoo",
                exclude_characters='(" %+~`#$&*()|[]}{:;<>?!\'/^-,@_=\\'), # generate secret password for 'odoo' user
            cloudwatch_logs_exports=["postgresql"],
            removal_policy=RemovalPolicy.DESTROY      # dev
            )
        
        #endpointaddress = dbcluster.cluster_endpoint.hostname # hostname of the dbcluster to pass to odoo
        #dbpassword = ecs.Secret.from_secrets_manager(
        #    dbcluster.secret, field="password") # secret containing the password auto generated by ...from_generated_secret("odoo")
        
        endpointaddress = data_base.db_instance_endpoint_address
        dbpassword = ecs.Secret.from_secrets_manager(
            data_base.secret, field="password") # secret containing the password auto generated by ...from_generated_secret("odoo")
        
        # task image options for Fargate service references odoo docker hub image
        task_image_options=ecs_patterns.ApplicationLoadBalancedTaskImageOptions(
            image=ecs.ContainerImage.from_registry(odoo_version),
            container_name="odooContainer",
            container_port=8069,
            secrets={"POSTGRES_PASSWORD":dbpassword},
            environment={"DB_PORT_5432_TCP_ADDR":endpointaddress}
            )
        
        '''
        # task image options for Fargate service references local odoo Dockerfile & conf
        task_image_options=ecs_patterns.ApplicationLoadBalancedTaskImageOptions(
            image=ecs.ContainerImage.from_asset(directory="./odoo", 
            build_args={"BUILD_ARGS": "--no-cache",
                }),
           secrets={"POSTGRES_PASSWORD":dbpassword},
           environment={"DB_PORT_5432_TCP_ADDR":endpointaddress,
                        },
           container_port=8069 
                )
            '''

        # Create EFS storage for "What Odoo stores on the file system are the application's static assets, 
        # such as JavaScript and CSS files, and session context files."
        file_system = efs.FileSystem(self, "odooEfsFileSystem",
            vpc=vpc,
            lifecycle_policy=efs.LifecyclePolicy.AFTER_14_DAYS,  # files are not transitioned to infrequent access (IA) storage by default
            performance_mode=efs.PerformanceMode.GENERAL_PURPOSE,  # default
            out_of_infrequent_access_policy=efs.OutOfInfrequentAccessPolicy.AFTER_1_ACCESS,
            removal_policy=RemovalPolicy.DESTROY # dev
            )

        # efs access point
        access_point = efs.AccessPoint(self, "odooEfsAccessPoint",
            file_system=file_system,
            path="/",
            create_acl=efs.Acl(
                owner_uid="0",
                owner_gid="0",
                permissions="755"
                ),
            posix_user=efs.PosixUser(
                uid="0",
                gid="0"
                )
            )

        # Fargate Service for odoo docker image with auto load balancer
        application = ecs_patterns.ApplicationLoadBalancedFargateService(self, 
            "odooFargateService",
            cluster=cluster,            # Required
            cpu=1024,                    # Default is 256
            ## Desired count must be 1 on first deployment to prevent DB create error in Odoo.
            ## Can be increased to 2 for subsequent deployments. To do - automate this.
            desired_count=2,            # Default is 1 suggested is 2
            min_healthy_percent=50,     # Default is 50% of desired count
            memory_limit_mib=2048,      # Default is 512
            public_load_balancer=True,  # Default is True
            #assign_public_ip=True,
            task_image_options=task_image_options,
            health_check_grace_period=Duration.seconds(300), # Default is 60
            idle_timeout=Duration.seconds(60),  #default is 60
            platform_version=ecs.FargatePlatformVersion.VERSION1_4, # must specify VERSION1_4 for efs to mount
            )
        
        # added to help reduce load on Odoo.
        application.target_group.configure_health_check(
            healthy_threshold_count=2,  #5 is the default
            interval=Duration.seconds(60),   #300 is the max!
            timeout=Duration.seconds(30),    #120 is the max!
            unhealthy_threshold_count=5,
            path="/web/database/selector",
        )
        
        # creat an EFS volume
        volume_name = "odooVolume"
        application.task_definition.add_volume(name=volume_name,
            efs_volume_configuration=ecs.EfsVolumeConfiguration(
                file_system_id=file_system.file_system_id,
                authorization_config=ecs.AuthorizationConfig(
                    access_point_id=access_point.access_point_id,
                    iam="ENABLED"
                    ),
                transit_encryption="ENABLED"   # enable encryption for EFS data in transit
                )
            )
        
        # add mount point for Odoo's data dir
        application.task_definition.default_container.add_mount_points(
            ecs.MountPoint(
                container_path="/var/lib/odoo",
                read_only=False,
                source_volume=volume_name  # must match name string in add_volume
                )
            )
        
        # Grant containers access to file system - two ways to achieve
        # the same thing...
        #file_system.grant(application.task_definition.task_role,
        #    'elasticfilesystem:ClientWrite',
        #    'elasticfilesystem:ClientRead'
        #    )
        # or this way
        application.task_definition.add_to_task_role_policy(iam.PolicyStatement(actions=
                ['elasticfilesystem:ClientWrite',
                'elasticfilesystem:ClientRead'
                ],
                resources=[file_system.file_system_arn])
            )
        
        # enable sticky sessions -- not needed now efs works
        #application.target_group.enable_cookie_stickiness(duration=Duration.hours(12))

        # connections - allows traffic between the default, automatically created security groups
        #dbport = dbcluster.connections.default_port
        dbport = data_base.connections.default_port
        efsport = file_system.connections.default_port

        #dbcluster.connections.allow_default_port_from(application.service)
        data_base.connections.allow_default_port_from(application.service)
        #data_base.connections.allow_default_port_from_any_ipv4()
        
        #application.service.connections.allow_from(dbcluster, port_range=dbport)
        application.service.connections.allow_from(data_base, port_range=dbport)
        application.service.connections.allow_from(file_system, port_range=efsport)
   
        file_system.connections.allow_default_port_from(application.service)


#############################################################################################
##                   Code to install custom addons below.                                  ##
#############################################################################################
        # add mount point for Odoo's custom modules dir - path from containers odoo.conf
        application.task_definition.default_container.add_mount_points(
            ecs.MountPoint(
                container_path='/mnt/extra-addons',
                read_only=False,
                source_volume=volume_name  # must match name string in add_volume
                )
            )
            
        ## create s3 to add addons to
        addon_bucket = s3.Bucket(self, 'AddonBucket',
            bucket_name=f'addon-bucket-{odoo_version.replace(":","")}-{environ}',   # does not allow ':' in name
            auto_delete_objects=True,
            removal_policy=RemovalPolicy.DESTROY
            )

        ## Lambda to copy files from S3 to addons mount point
        addon_lambda = lambda_.Function(self, 's3toEFSlambda',
            vpc=vpc,
            filesystem=lambda_.FileSystem.from_efs_access_point(access_point, '/mnt/extra-addons'),
            runtime=lambda_.Runtime.PYTHON_3_8,
            code=lambda_.Code.from_asset('addon_lambda'),
            handler='addon_lambda.lambda_handler',
            )

        ## Event triggered when file added to bucket
        upload_trigger = event_sources.S3EventSource(addon_bucket, 
            events=[s3.EventType.OBJECT_CREATED])
        ## lock event to lambda
        addon_lambda.add_event_source(upload_trigger)            
        
        ## permissions
        addon_bucket.grant_read_write(addon_lambda)
        addon_lambda.add_to_role_policy(iam.PolicyStatement(actions=
            ['elasticfilesystem:ClientWrite',
            'elasticfilesystem:ClientRead'
            ],
            resources=[file_system.file_system_arn])
            )

#############################################################################################
##                   Changes in development environment can be added here                  ##
#############################################################################################
        if environ == 'danger':         # danger tag added so this isn't used!
        
            # lambda with API for checking files in EFS (not secure!)
            api_lambda = lambda_.Function(self, 'efsConnectionAPI',
                vpc=vpc,
                filesystem=lambda_.FileSystem.from_efs_access_point(access_point, '/mnt/extra-addons'),
                runtime=lambda_.Runtime.PYTHON_3_8,
                code=lambda_.Code.from_asset('api_lambda'),
                handler='efs_api.lambda_handler'
                )
            
            # API for api_lambda - checking filesystem events
            EFS_api = apigateway.LambdaRestApi(self, 'EFSAccess',
                handler=api_lambda)

